(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{52:function(e,t,a){"use strict";a.r(t);var n=a(0),i=function(e){var t,a,n,i,r,s,l=(n=void 0,i="functional programming",r="data structures",s="trees",(t={}).type=a="post",t.internal=n,t.contentType="markdown",t.slug="implementing-a-trie",t.content=n,t.createdAt=new Date(15742944e5),t.updatedAt=new Date(1663773293333),t.layout=a,t.title="Tries company",t.date="2019-11-21",t.tags=[i,r,s],t.markdownHeadings=[{text:"Implementing a Trie in Haskell",slug:"implementing-a-trie-in-haskell",level:1},{text:"What is a Trie?",slug:"what-is-a-trie",level:2},{text:"How to implement a Trie?",slug:"how-to-implement-a-trie",level:2},{text:"A Tree",slug:"a-tree",level:3},{text:"A Trie",slug:"a-trie",level:3},{text:"My Biggest mistake",slug:"my-biggest-mistake",level:2},{text:"Fixing my biggest mistake",slug:"fixing-my-biggest-mistake",level:2},{text:"What's in it?",slug:"whats-in-it",level:2},{text:"Conclusion",slug:"conclusion",level:2}],t.excerpt="<p>Once upon a time (five months ago) I was doing a phone screening for a <em>tech job</em>. To my horror, I was asked to\nname a Tree that wasn't a binary search Tree. Being a complete philistine, I had no answer. I was rejected on\nthe spot. From that day on I have made it my mission to learn about every variation of a Tree that can be\nimplemented with a small amount of effort in Haskell.</p>\n",t.permalink="/posts/implementing-a-trie.html",t.assets={},t.attributes=t,t.tagsInfo=[{name:i,permalink:"/tags/functional-programming"},{name:r,permalink:"/tags/data-structures"},{name:s,permalink:"/tags/trees"}],t),o=e.options.beforeCreate||[];e.options.beforeCreate=[function(){this.$page=l}].concat(o);["layout","transition"].forEach((function(t){var a=e.options.PageComponent;a&&(e.options[t]=a[t]),void 0===e.options[t]&&(e.options[t]=l[t])})),l.slug&&(e.options.name="page-wrapper-"+l.slug.replace(/[^0-9a-z\-]/gi,"-"))},r=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("layout-manager",[a("h1",{attrs:{id:"implementing-a-trie-in-haskell"}},[e._v("Implementing a Trie in Haskell")]),e._v(" "),a("p",[e._v("Once upon a time (five months ago) I was doing a phone screening for a "),a("em",[e._v("tech job")]),e._v(". To my horror, I was asked to\nname a Tree that wasn't a binary search Tree. Being a complete philistine, I had no answer. I was rejected on\nthe spot. From that day on I have made it my mission to learn about every variation of a Tree that can be\nimplemented with a small amount of effort in Haskell.")]),e._v(" "),a("p",[e._v("Today we take on "),a("em",[e._v("The Trie")])]),e._v(" "),a("p",[e._v("This article is mostly meant as a demonstration of what a Trie is. This is a totally\nnaive implementation, which is based on skimming the "),a("saber-link",{attrs:{to:"https://en.wikipedia.org/wiki/Trie"}},[e._v("wikipedia article about Tries")]),e._v(".\nAs such you probably shouldn't use this code anywhere.")],1),e._v(" "),a("p",[e._v("Although this is written in haskell, I've tried to avoid anything too weird.\nHopefully this code will be comprehensible for someone who has written Elm.")]),e._v(" "),a("p",[e._v("We'll start by watching me implementing a Trie incorrectly, realising my\nmistake, and then correcting it.")]),e._v(" "),a("h2",{attrs:{id:"what-is-a-trie"}},[e._v("What is a Trie?")]),e._v(" "),a("p",[e._v("A Trie (AKA a Prefix Tree) is a Tree where each node is labelled by some\nvalue. When we traverse the tree these labels can be concatenanted together to find the\nvalue represented by a leaf node.")]),e._v(" "),a("p",[e._v("For example I might store my friends names in a Trie like this:")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":""}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-text"}},[a("code",{pre:!0,attrs:{class:"language-text"}},[e._v("B\n      |\n   ______\n  |   |  |\n  O   I  A __\n  |   |  |   |\n  B   L  Z   R\n      |      |\n      L      B\n\n-- This Trie contains the names Bob, Bill, Baz, and Barb.      ALl my friends.")])])]),a("p",[e._v("Tries are useful for things like creating an autocompleting\nsearchbox on your Web 2.0 App. They can really deliver a lot of business value and help you meet your KPIs.")]),e._v(" "),a("h2",{attrs:{id:"how-to-implement-a-trie"}},[e._v("How to implement a Trie?")]),e._v(" "),a("h3",{attrs:{id:"a-tree"}},[e._v("A Tree")]),e._v(" "),a("p",[e._v("A typical binary tree in Haskell can be implemented as follows")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("data Tree a = Node a (Tree a) (Tree a) | Leaf")])])]),a("h3",{attrs:{id:"a-trie"}},[e._v("A Trie")]),e._v(" "),a("p",[e._v("But in the case of a Trie, we aren't certain how many children a given Node will\nhave. We also want to be able to access a Node's children based on the value\nthey contain.")]),e._v(" "),a("p",[e._v("That sounds an awful lot like a Map (AKA a Dictionary)...")]),e._v(" "),a("p",[e._v("So let's represent the children using a Map")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("import qualified Data.Map.Strict as M\n-- We import a Data.Map, to act as our Dictionary\n\ndata Trie = Node (M.Map Char Trie) \n  deriving (Eq, Show)")])])]),a("p",[e._v("A really simple Trie with just two words, 'hi' and 'hey' using this structure would\nlook something like this.")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("Node { h = Node { i = Node { }, e = Node { y = Node { } } } }")])])]),a("p",[e._v("Writing out nodes by hand is no fun. So let's write a function to insert a word.")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("-- First we make a helpful 'empty Trie' constant\nempty :: Trie\nempty = Node M.empty\n\n\n-- Then we define the type of our insert function\ninsert :: String -> Trie -> Trie\n\n-- If the String is empty, we return the Trie as it was\ninsert \"\" t = t  \n\n-- Otherwise we split the first character out of the string\n-- and check if that character already exists as a child of the Node we're\n-- looking at\ninsert (c:rest) (Node children) =\n  case M.lookup c children of\n\n    -- If the character wasn't already there, then we add an empty Trie\n    -- under that character to our Map, and then add the rest of the string to \n    -- that new subTrie!\n    Nothing ->\n      Node $ M.insert c (insert rest empty) children\n\n    -- If the character is already in the Trie then we can recursively call \n    -- insert on that SubTrie with the rest of our string\n    Just matchingChildNode ->\n      Node (M.insert c (insert rest matchingChildNode) children)")])])]),a("p",[e._v("Now we can construct the same Trie we saw previously, "),a("em",[e._v("but this time with code")])]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v('ourTrie = insert "hi" $ insert "hey" empty')])])]),a("p",[e._v("If we run this in our Repl we get")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":""}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-text"}},[a("code",{pre:!0,attrs:{class:"language-text"}},[e._v("Node (fromList\n  [ ('h', Node (fromList\n    [ ('e',Node (fromList\n      [ ('y',Node (fromList [] )) ]))\n  , ('i',Node (fromList [])) ])) ])")])])]),a("p",[e._v("Cool!")]),e._v(" "),a("h2",{attrs:{id:"my-biggest-mistake"}},[e._v("My Biggest mistake")]),e._v(" "),a("p",[e._v("An observant reader might noticed that this Trie implementation is WRONG and BAD")]),e._v(" "),a("p",[e._v('What happens to our Trie if, for KPI related reasons, we need to insert the words "hello" and "hell"?')]),e._v(" "),a("p",[e._v("We can add them both, but there is no possible way us to tell looking at the resulting Trie that the word hell was ever there. It's gone. Vanished. Verschwunden.")]),e._v(" "),a("p",[e._v("We have no way of to distinguish between words that were intentionally added\nto the Trie, and random prefixes that have no meaning by themselves.")]),e._v(" "),a("h2",{attrs:{id:"fixing-my-biggest-mistake"}},[e._v("Fixing my biggest mistake")]),e._v(" "),a("p",[e._v("This is all fine of course. We can change our Trie defintion such that each node\ncan either hold onto a specific value, or be empty. An empty node meaning that\nthe it is simply a step on the path to a node that "),a("em",[e._v("does")]),e._v(" represent some\nspecific word.")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("data Trie \n  = Node String (M.Map Char Trie) \n  | Empty (M.Map Char Trie)\n      deriving (Eq, Show)\n\nempty :: Trie\nempty = Empty M.empty")])])]),a("p",[e._v("Let' also make some helper functions for working with our new structure")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("getChildren :: Trie -> M.Map Char Trie\ngetChildren (Node _ c) = c\ngetChildren (Empty c) = c\n\nsetChildren :: Trie -> M.Map Char Trie -> Trie\nsetChildren (Node s _) newChildren = Node s newChildren\nsetChildren (Empty _) newChildren = Empty newChildren")])])]),a("p",[e._v("Now we need to update our insert function to save the word that we are inserting at\nthe end of the Trie branch it is added to")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("insert :: String -> Trie -> Trie\ninsert word trie = recurse word trie\n  where\n    recurse :: String -> Trie -> Trie")])])]),a("p",[e._v("we use an internal helper function, that I've called "),a("code",{pre:!0},[e._v("recurse")]),e._v(" so we can keep hold of the word we are adding - even while recursing.")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v('recurse "" t = Node word (getChildren t)')])])]),a("p",[e._v("If our string is empty, it means we've finished adding all the characters that make up our word\nto the trie - so we can save the full word at this Node and then stop. Phew")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("recurse (c:rest) t = \n      let children = (getChildren t)\n      in case M.lookup c children of\n        Just matchingChildNode ->\n          setChildren t (M.insert c (recurse rest matchingChildNode) children)\n        Nothing ->\n          setChildren t $ M.insert c (recurse rest empty) children")])])]),a("p",[e._v("If there are still characters to add to the Trie, we can recursively add them in much the same way we did before.\nWe just need to adjust this function a bit to avoid destroying other words that we've already saved in our Trie.")]),e._v(" "),a("p",[e._v("Nice!")]),e._v(" "),a("h2",{attrs:{id:"whats-in-it"}},[e._v("What's in it?")]),e._v(" "),a("p",[e._v("The really useful feature of a Trie, it seems, is to be able to tell us all the\nsuffixes for a given Node. In our example above, I might start with the letter 'h'\nand be told that the possible endings of the word are 'i' and 'ey'. Very useful.")]),e._v(" "),a("p",[e._v("It turns out that writing this function for our Trie is "),a("em",[e._v("really")]),e._v(" easy.")]),e._v(" "),a("p",[e._v("first we write a function that can help us get a value out of a given node of a Trie.")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("getValue :: (Applicative m, Monoid (m String)) => Trie -> m String\ngetValue (Empty _) = mempty\ngetValue (Node nodeValue _) = pure nodeValue")])])]),a("p",[e._v("The cool thing about this function is that it will return a different type\ndepending on the context we use it in. For example if we used it in a context where we expected a Maybe. We'll get a Maybe String.")]),e._v(" "),a("p",[e._v("In this case we actually want to build a list of values, and this function will helpfully also return values in that format. To get all the words in our Trie we can write a function that recursively get's the values at each node in our Trie, and returns them all in one big list")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v("getWords :: Trie -> [ String ]\ngetWords t = getValue t <> \n               foldMap getWords (getChildren t)")])])]),a("p",[e._v("Tidy")]),e._v(" "),a("p",[e._v("If we test this like so")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v('main = do\n  print $\n    getWords $ insert "hey" $ insert "hello" $ insert "egg" empty')])])]),a("p",[e._v("We'll see")]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v('["egg", "hello", "hey"]')])])]),a("p",[e._v("Nice!")]),e._v(" "),a("h2",{attrs:{id:"conclusion"}},[e._v("Conclusion")]),e._v(" "),a("p",[e._v("wow. What a journey.\nI hope this was in some way useful. It certainly was for me! Next time a phone interviewer asks me to name\n'"),a("em",[e._v("any one data structure that isn't a binary search Trie")]),e._v("' I'll have an answer for them!")]),e._v(" "),a("p",[e._v("Below you'll find the complete code, which you can play around with. It's been edited slightly to be more generic. Allowing us to store any lists of values, rather than just Strings (aka lists of characters).")]),e._v(" "),a("p",[e._v("Suggested exercise for the reader")]),e._v(" "),a("ul",[a("li",[e._v("Write an autocomplete function that takes the start of a word and a trie, and tells us the possible complete words we could make!")]),e._v(" "),a("li",[e._v("Write a function to delete words from the Trie!")]),e._v(" "),a("li",[e._v("Think of an application for a Trie that isn't building autocomplete functionality")]),e._v(" "),a("li",[e._v("Try implementing this in C (jk)")])]),e._v(" "),a("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"haskell"}},[a("pre",{pre:!0,attrs:{class:"saber-highlight-code language-haskell"}},[a("code",{pre:!0,attrs:{class:"language-haskell"}},[e._v('{-# Language ScopedTypeVariables #-}\n\nmodule GenTree where\n\nimport qualified Data.Map.Strict as M\n\ndata Trie a = Node [a] (M.Map a (Trie a)) | Empty (M.Map a (Trie a))\n  deriving (Eq, Show)\n\nempty :: Trie a\nempty = Empty M.empty\n\ngetValue :: (Applicative m, Monoid (m [a])) => Trie a -> m [a]\ngetValue (Empty _) = mempty\ngetValue (Node nodeValue _) = pure nodeValue\n\ngetChildren :: Trie a -> M.Map a (Trie a)\ngetChildren (Node _ c) = c\ngetChildren (Empty c) = c\n\nsetChildren :: Trie a -> M.Map a (Trie a) -> Trie a\nsetChildren (Node s _) newChildren = Node s newChildren\nsetChildren (Empty _) newChildren = Empty newChildren\n\n\ninsert :: forall a. (Ord a) => [a] -> Trie a -> Trie a\ninsert word trie = recurse word trie\n  where\n    recurse :: [a] -> Trie a -> Trie a\n    recurse [] t = Node word (getChildren t)\n\n    recurse (c:rest) t = \n      let children = (getChildren t)\n      in case M.lookup c children of\n        Just matchingChildNode ->\n          setChildren t (M.insert c (recurse rest matchingChildNode) children)\n        Nothing ->\n          setChildren t $ M.insert c (recurse rest (empty)) children\n\ngetWords :: Trie a -> [ [ a ] ]\ngetWords t = getValue t <> \n               foldMap getWords (getChildren t)\n      \nmain = do\n  print $\n    getWords $ insert "hey" $ insert "hello" $ insert "egg" empty\n  print $\n    getWords $ insert [1, 2, 3] $ insert [1, 4, 5] $ insert [1, 50, 2] empty')])])])])}),[],!1,null,null,null);"function"==typeof i&&i(r);t.default=r.exports}}]);